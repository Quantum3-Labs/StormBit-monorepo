{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";\nimport {SafeERC20} from \"../utils/SafeERC20.sol\";\nimport {IERC4626} from \"../../../interfaces/IERC4626.sol\";\nimport {Math} from \"../../../utils/math/Math.sol\";\n\n/**\n * @dev Implementation of the ERC4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * [CAUTION]\n * ====\n * In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning\n * with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n * similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * Since v4.9, this implementation uses virtual assets and shares to mitigate that risk. The `_decimalsOffset()`\n * corresponds to an offset in the decimal representation between the underlying asset's decimals and the vault\n * decimals. This offset also determines the rate of virtual shares to virtual assets in the vault, which itself\n * determines the initial exchange rate. While not fully preventing the attack, analysis shows that the default offset\n * (0) makes it non-profitable, as a result of the value being captured by the virtual shares (out of the attacker's\n * donation) matching the attacker's expected gains. With a larger offset, the attack becomes orders of magnitude more\n * expensive than it is profitable. More details about the underlying math can be found\n * xref:erc4626.adoc#inflation-attack[here].\n *\n * The drawback of this approach is that the virtual shares do capture (a very small) part of the value being accrued\n * to the vault. Also, if the vault experiences losses, the users try to exit the vault, the virtual shares and assets\n * will cause the first user to exit to experience reduced losses in detriment to the last users that will experience\n * bigger losses. Developers willing to revert back to the pre-v4.9 behavior just need to override the\n * `_convertToShares` and `_convertToAssets` functions.\n *\n * To learn more, check out our xref:ROOT:erc4626.adoc[ERC-4626 guide].\n * ====\n */\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using Math for uint256;\n\n    IERC20 private immutable _asset;\n    uint8 private immutable _underlyingDecimals;\n\n    /**\n     * @dev Attempted to deposit more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to mint more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);\n\n    /**\n     * @dev Attempted to withdraw more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to redeem more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\n     */\n    constructor(IERC20 asset_) {\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _underlyingDecimals = success ? assetDecimals : 18;\n        _asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool, uint8) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Decimals are computed by adding the decimal offset on top of the underlying asset's decimals. This\n     * \"original\" value is cached during construction of the vault contract. If this read operation fails (e.g., the\n     * asset has not been created yet), a default of 18 is used to represent the underlying asset's decimals.\n     *\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20Metadata, ERC20) returns (uint8) {\n        return _underlyingDecimals + _decimalsOffset();\n    }\n\n    /** @dev See {IERC4626-asset}. */\n    function asset() public view virtual returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4626-totalAssets}. */\n    function totalAssets() public view virtual returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    /** @dev See {IERC4626-convertToShares}. */\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-convertToAssets}. */\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-maxDeposit}. */\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint}. */\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw}. */\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-maxRedeem}. */\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit}. */\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-previewMint}. */\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Ceil);\n    }\n\n    /** @dev See {IERC4626-previewWithdraw}. */\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Ceil);\n    }\n\n    /** @dev See {IERC4626-previewRedeem}. */\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-deposit}. */\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256) {\n        uint256 maxAssets = maxDeposit(receiver);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);\n        }\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint}.\n     *\n     * As opposed to {deposit}, minting is allowed even if the vault is in a state where the price of a share is zero.\n     * In this case, the shares will be minted without requiring any assets to be deposited.\n     */\n    function mint(uint256 shares, address receiver) public virtual returns (uint256) {\n        uint256 maxShares = maxMint(receiver);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxMint(receiver, shares, maxShares);\n        }\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw}. */\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem}. */\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {\n        // If _asset is ERC777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If _asset is ERC777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "contracts/AssetManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IERC20} from \"./interfaces/token/IERC20.sol\";\nimport {IERC4626} from \"./interfaces/token/IERC4626.sol\";\nimport {IGovernable} from \"./interfaces/utils/IGovernable.sol\";\nimport {IInitialize} from \"./interfaces/utils/IInitialize.sol\";\nimport {BaseVault} from \"./vaults/BaseVault.sol\";\nimport {IAssetManager} from \"./interfaces/managers/asset/IAssetManager.sol\";\nimport {ILoanManager} from \"./interfaces/managers/loan/ILoanManager.sol\";\nimport {ILendingManager} from \"./interfaces/managers/lending/ILendingManager.sol\";\n\n/// @author Quantum3 Labs\n/// @title Stormbit Asset Manager\n/// @notice entrypoint for all asset management operations\n\ncontract StormbitAssetManager is Initializable, IGovernable, IInitialize, IAssetManager {\n    using Math for uint256;\n\n    address private _governor;\n    ILoanManager public loanManager;\n    ILendingManager public lendingManager;\n\n    mapping(address token => bool isSupported) tokens; // check if token is supported\n    mapping(address token => address vaultToken) vaultTokens; // token to vault mapping\n\n    constructor(address initialGovernor) {\n        _governor = initialGovernor;\n    }\n\n    modifier onlyGovernor() {\n        require(msg.sender == _governor, \"StormbitAssetManager: not governor\");\n        _;\n    }\n\n    modifier onlyLoanManager() {\n        require(msg.sender == address(loanManager), \"StormbitAssetManager: not loan manager\");\n        _;\n    }\n\n    modifier onlyLendingManager() {\n        require(msg.sender == address(lendingManager), \"StormbitAssetManager: not lending manager\");\n        _;\n    }\n\n    // -----------------------------------------\n    // -------- PUBLIC FUNCTIONS ---------------\n    // -----------------------------------------\n\n    /// @dev used to initialize loan and lend manager address\n    /// @param loanManagerAddr address of the loan manager\n    /// @param lendingManagerAddr address of the lending manager\n    function initialize(address loanManagerAddr, address lendingManagerAddr) public override initializer {\n        loanManager = ILoanManager(loanManagerAddr);\n        lendingManager = ILendingManager(lendingManagerAddr);\n    }\n\n    /// @dev allow depositor deposit assets to the vault\n    /// @param token address of the token\n    /// @param assets amount of assets to deposit\n    function deposit(address token, uint256 assets) public override {\n        _checkTokenSupported(token);\n        address vaultToken = vaultTokens[token]; // get the corresponding vault\n        // first make sure can transfer user token to manager\n        // todo: use safe transfer\n        bool isSuccess = IERC20(token).transferFrom(msg.sender, address(this), assets);\n        if (!isSuccess) {\n            revert(\"StormbitAssetManager: transfer failed\");\n        }\n        IERC20(token).approve(vaultToken, assets);\n        IERC4626(vaultToken).deposit(assets, msg.sender);\n        emit Deposit(msg.sender, token, assets);\n    }\n\n    /// @dev same function as deposit, but allow user to deposit on behalf of another user\n    function depositFrom(address token, uint256 assets, address depositor, address receiver) public override {\n        _checkTokenSupported(token);\n        address vaultToken = vaultTokens[token]; // get the corresponding vault\n        // first make sure can transfer user token to manager\n        bool isSuccess = IERC20(token).transferFrom(depositor, address(this), assets);\n        if (!isSuccess) {\n            revert(\"StormbitAssetManager: transfer failed\");\n        }\n        IERC20(token).approve(vaultToken, assets);\n        IERC4626(vaultToken).deposit(assets, receiver);\n        emit Deposit(receiver, token, assets);\n    }\n\n    /// @dev note that we dont require the token to be whitelisted\n    function withdraw(address token, uint256 assets) public override {\n        // withdraw here is withdraw from shares to asset\n        _checkTokenSupported(token);\n        address vaultToken = vaultTokens[token];\n        uint256 sharesBurned = IERC4626(vaultToken).withdraw(assets, msg.sender, msg.sender);\n        emit Withdraw(msg.sender, vaultToken, assets, sharesBurned);\n    }\n\n    /// @dev call by lending manager, use for execute loan, redeem shares for borrower\n    function borrowerWithdraw(address borrower, address token, uint256 assets) public override onlyLendingManager {\n        address vaultToken = getVaultToken(token);\n        IERC4626(vaultToken).withdraw(assets, borrower, msg.sender);\n        emit BorrowerWithdraw(borrower, token, assets);\n    }\n\n    /// @dev allow governor to add a new token\n    /// @param token address of the token\n    function addToken(address token) public override onlyGovernor {\n        if (tokens[token]) return;\n        tokens[token] = true;\n        // deploy the vault\n        BaseVault vault = new BaseVault(\n            IERC20(token),\n            address(this),\n            string(abi.encodePacked(\"Stormbit \", IERC20(token).symbol())),\n            string(abi.encodePacked(\"s\", IERC20(token).symbol()))\n        );\n        // update the mapping\n        vaultTokens[token] = address(vault);\n        emit AddToken(token, address(vault));\n    }\n\n    /// @dev allow governor to remove the support of a token\n    /// @param token address of the token\n    function removeToken(address token) public override onlyGovernor {\n        // get the vault address\n        address vaultToken = vaultTokens[token];\n        // check if vault is empty\n        require(IERC4626(vaultToken).totalSupply() == 0, \"StormbitAssetManager: vault not empty\");\n        tokens[token] = false;\n        emit RemoveToken(token, vaultToken);\n    }\n\n    // -----------------------------------------\n    // ----------- INTERNAL FUNCTIONS ----------\n    // -----------------------------------------\n    function _checkTokenSupported(address token) internal view {\n        require(tokens[token], \"StormbitAssetManager: token not supported\");\n    }\n\n    // -----------------------------------------\n    // -------- PUBLIC GETTER FUNCTIONS --------\n    // -----------------------------------------\n\n    function governor() public view override returns (address) {\n        return _governor;\n    }\n\n    /// @dev check if token is supported\n    /// @param token address of the token\n    function isTokenSupported(address token) public view override returns (bool) {\n        return tokens[token];\n    }\n\n    /// @dev get vault token  address\n    function getVaultToken(address token) public view override returns (address) {\n        return vaultTokens[token];\n    }\n\n    /// @dev get user shares on specific vault\n    function getUserShares(address token, address user) public view override returns (uint256) {\n        address vaultToken = vaultTokens[token];\n        IERC4626 vault = IERC4626(vaultToken);\n        return vault.balanceOf(user);\n    }\n\n    /// @dev convert assets to shares based on the vault\n    function convertToShares(address token, uint256 assets) public view override returns (uint256) {\n        address vaultToken = vaultTokens[token];\n        IERC4626 vault = IERC4626(vaultToken);\n        return vault.convertToShares(assets);\n    }\n\n    /// @dev convert shares to assets based on the vault\n    function convertToAssets(address token, uint256 shares) public view override returns (uint256) {\n        address vaultToken = vaultTokens[token];\n        IERC4626 vault = IERC4626(vaultToken);\n        return vault.convertToAssets(shares);\n    }\n}\n"
    },
    "contracts/hooks/BaseHook.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {IHooks} from \"../interfaces/hooks/IHooks.sol\";\nimport {Hooks} from \"../libraries/Hooks.sol\";\nimport {StormbitLendingManager} from \"../LendingManager.sol\";\n\nabstract contract BaseHook is IHooks {\n    error NotManager();\n\n    StormbitLendingManager public immutable manager;\n\n    constructor(StormbitLendingManager _manager) {\n        manager = _manager;\n        validateHookAddress(this);\n    }\n\n    modifier onlyByManager() {\n        if (msg.sender != address(manager)) revert NotManager();\n        _;\n    }\n\n    function getHookPermissions() public pure virtual returns (Hooks.Permissions memory);\n\n    function validateHookAddress(BaseHook _this) internal pure virtual {\n        Hooks.validateHookPermissions(_this, getHookPermissions());\n    }\n}\n"
    },
    "contracts/hooks/Whitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {Hooks} from \"../libraries/Hooks.sol\";\nimport {BaseHook} from \"./BaseHook.sol\";\nimport {StormbitLendingManager} from \"../LendingManager.sol\";\n\ncontract WhiteList is BaseHook {\n    mapping(address user => bool isWhiteListed) private whitelist;\n\n    constructor(StormbitLendingManager _manager, address[] memory whiteListedAddrs) BaseHook(_manager) {\n        for (uint256 i = 0; i < whiteListedAddrs.length; i++) {\n            whitelist[whiteListedAddrs[i]] = true;\n        }\n    }\n\n    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {\n        return Hooks.Permissions({beforeDepositToTerm: true});\n    }\n\n    function beforeDepositToTerm(address from, address token, uint256 termId, uint256 shares)\n        external\n        override\n        onlyByManager\n        returns (bool)\n    {\n        require(whitelist[from], \"WhiteList: not whitelisted\");\n        return true;\n    }\n\n    function addWhiteList(address user) external {\n        whitelist[user] = true;\n    }\n}\n"
    },
    "contracts/interfaces/hooks/IHooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/// @author Quantum3 Labs\n/// @title Stormbit Hooks Interface\ninterface IHooks {\n    function beforeDepositToTerm(address from, address token, uint256 termId, uint256 shares) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IStormbitRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/// @author Quantum3 Labs\n/// @title Stormbit Registry Interface\ninterface IStormbitRegistry {\n    event Registered(address indexed user, string username);\n\n    function register(string memory) external;\n}\n"
    },
    "contracts/interfaces/managers/asset/IAssetManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/// @author Quantum3 Labs\n/// @title Stormbit Asset Manager Interface\n/// TODO split into different interfaces according to funcionality\ninterface IAssetManager {\n    event AddToken(address indexed token, address indexed vault);\n\n    event RemoveToken(address indexed token, address indexed vault);\n\n    event Deposit(address indexed user, address indexed token, uint256 assets);\n\n    /// @dev note that withdraw event uses assets instead of shares\n    event Withdraw(address indexed user, address indexed vaultToken, uint256 assets, uint256 sharesBurned);\n\n    event BorrowerWithdraw(address indexed borrower, address indexed token, uint256 shares);\n\n    function addToken(address _asset) external;\n\n    function removeToken(address _asset) external;\n\n    function isTokenSupported(address token) external view returns (bool);\n\n    function getVaultToken(address token) external view returns (address);\n\n    function getUserShares(address token, address user) external view returns (uint256);\n\n    function convertToShares(address token, uint256 assets) external view returns (uint256);\n\n    function convertToAssets(address token, uint256 shares) external view returns (uint256);\n\n    function deposit(address token, uint256 assets) external;\n\n    function depositFrom(address token, uint256 assets, address depositor, address receiver) external;\n\n    function withdraw(address token, uint256 shares) external;\n\n    function borrowerWithdraw(address borrower, address token, uint256 assets) external;\n}\n"
    },
    "contracts/interfaces/managers/asset/IAssetManagerView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/// @author Quantum3 Labs\n/// @title Stormbit Asset Manager Getter Functions Interface\n/// TODO split into different interfaces according to funcionality\ninterface IAssetManagerView {\n    function isTokenSupported(address token) external view returns (bool);\n\n    function getVaultToken(address token) external view returns (address);\n\n    function getUserShares(address token, address user) external view returns (uint256);\n\n    function convertToShares(address token, uint256 assets) external view returns (uint256);\n\n    function convertToAssets(address token, uint256 shares) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/managers/asset/IDepositWithdraw.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/// @author Quantum3 Labs\n/// @title Stormbit Deposit & withdraw Interface\n/// TODO split into different interfaces according to funcionality\ninterface IDepositWithdraw {\n    event Deposit(address indexed user, address indexed token, uint256 assets);\n\n    /// @dev note that withdraw event uses assets instead of shares\n    event Withdraw(address indexed user, address indexed vaultToken, uint256 assets, uint256 sharesBurned);\n\n    event BorrowerWithdraw(address indexed borrower, address indexed token, uint256 shares);\n\n    function deposit(address token, uint256 assets) external;\n\n    function depositFrom(address token, uint256 assets, address depositor, address receiver) external;\n\n    function withdraw(address token, uint256 shares) external;\n\n    function borrowerWithdraw(address borrower, address token, uint256 shares) external;\n}\n"
    },
    "contracts/interfaces/managers/lending/IDelegation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/// @author Quantum3 Labs\n/// @title Stormbit Delegation Interface\n/// TODO split into different interfaces according to funcionality\ninterface IDelegation {\n    struct Shares {\n        uint256 disposableShares;\n        uint256 totalShares;\n        uint256 profit;\n    }\n\n    event DepositToTerm(uint256 indexed id, address indexed user, address indexed token, uint256 shares);\n\n    event WithdrawFromTerm(uint256 indexed id, address indexed user, address indexed token, uint256 shares);\n\n    event FreezeSharesOnTerm(uint256 indexed termId, address indexed token, uint256 shares);\n\n    function depositToTerm(uint256 termId, address token, uint256 shares) external;\n\n    function withdrawFromTerm(uint256 termId, address token, uint256 requestedDecrease) external;\n\n    function freezeTermShares(uint256 termId, uint256 shares, address token) external;\n}\n"
    },
    "contracts/interfaces/managers/lending/ILendingManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {IHooks} from \"../../hooks/IHooks.sol\";\n\n/// @author Quantum3 Labs\n/// @title Stormbit Lending Manager Interface\n/// TODO split into different interfaces according to funcionality\ninterface ILendingManager {\n    struct Balances {\n        uint256 available; // available for tracking disposable shares\n        uint256 weight; // weight is shares + profit\n        uint256 shares; // shares is weight but without profit\n    }\n\n    struct LendingTerm {\n        address owner;\n        uint256 comission; // TODO add balances and other ERC4626 custom fields\n        IHooks hooks;\n        mapping(uint256 termId => mapping(address vaultToken => Balances balances)) termBalances; // total shares controlled by the term owner\n        mapping(uint256 termId => uint256 nonZeroTokenBalanceCounter) termNonZeroTokenCounter; // track non zero token counter\n    }\n\n    struct LendingTermMetadata {\n        address owner;\n        uint256 comission;\n        IHooks hooks;\n    }\n\n    event LendingTermCreated(uint256 indexed id, address lender, uint256 comission);\n\n    event LendingTermRemoved(uint256 indexed id);\n\n    event BorrowerWithdraw(address indexed borrower, address indexed token, uint256 assets);\n\n    event DepositToTerm(uint256 indexed id, address indexed user, address indexed token, uint256 shares);\n\n    event WithdrawFromTerm(uint256 indexed id, address indexed user, address indexed token, uint256 shares);\n\n    event FreezeSharesOnTerm(uint256 indexed termId, address indexed token, uint256 shares);\n\n    event DistributeProfit(uint256 indexed termId, address indexed token, uint256 profit);\n\n    function createLendingTerm(uint256 comission, IHooks hooks) external returns (uint256);\n\n    function removeLendingTerm(uint256 id) external;\n\n    function borrowerWithdraw(address borrower, address token, uint256 assets) external;\n\n    function depositToTerm(uint256 termId, address token, uint256 shares) external;\n\n    function withdrawFromTerm(uint256 termId, address token, uint256 requestedDecrease) external;\n\n    function freezeTermShares(uint256 termId, uint256 shares, address token) external;\n\n    function distributeProfit(uint256 termId, address token, uint256 weight, uint256 shares, uint256 ownerProfit)\n        external;\n\n    function getLendingTerm(uint256 id) external returns (LendingTermMetadata memory);\n\n    function getTermFreezedShares(uint256 termId, address token) external view returns (uint256);\n\n    function getUserTotalDelegatedShares(address user, address token) external view returns (uint256);\n\n    function getLendingTermBalances(uint256 termId, address token) external view returns (uint256, uint256, uint256);\n}\n"
    },
    "contracts/interfaces/managers/lending/ILendingManagerView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {ILendingTerms} from \"./ILendingTerms.sol\";\n\n/// @author Quantum3 Labs\n/// @title Stormbit Lending Manager Getter Functions Interface\n/// TODO split into different interfaces according to funcionality\ninterface ILendingManagerView {\n    function getLendingTerm(uint256 id) external returns (ILendingTerms.LendingTerm memory);\n\n    function getTermFreezedShares(uint256 termId, address token) external view returns (uint256);\n\n    function getTermProfit(uint256 termId, address token) external returns (uint256);\n\n    function getUserTotalDelegatedShares(address user, address token) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/managers/lending/ILendingTerms.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {IHooks} from \"../../hooks/IHooks.sol\";\n\n/// @author Quantum3 Labs\n/// @title Stormbit Lending Terms Interface\n/// TODO split into different interfaces according to funcionality\ninterface ILendingTerms {\n    struct LendingTerm {\n        address owner;\n        uint256 comission; // TODO add balances and other ERC4626 custom fields\n        uint256 balances;\n        IHooks hooks;\n    }\n\n    event LendingTermCreated(uint256 indexed id, address lender, uint256 comission);\n    event LendingTermRemoved(uint256 indexed id);\n\n    function createLendingTerm(uint256 comission, IHooks hooks) external returns (uint256);\n\n    function removeLendingTerm(uint256 id) external;\n}\n"
    },
    "contracts/interfaces/managers/lending/ILendingWithdrawal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/// @author Quantum3 Labs\n/// @title Stormbit Lending Terms Interface\n/// TODO split into different interfaces according to funcionality\ninterface ILendingWithdrawal {\n    event LenderClaimLoanProfit(uint256 indexed termId, uint256 indexed loanId, address indexed token, uint256 profit);\n\n    event BorrowerWithdraw(address indexed borrower, address indexed token, uint256 shares);\n\n    function borrowerWithdraw(address borrower, address token, uint256 shares) external;\n\n    function lenderClaimLoanProfit(uint256 termId, uint256 loanId, address token) external;\n}\n"
    },
    "contracts/interfaces/managers/loan/IAllocation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/// @author Quantum3 Labs\n/// @title Stormbit Allocation Interface\n/// TODO split into different interfaces according to funcionality\ninterface IAllocation {\n    event TermAllocated(uint256 indexed loanId, uint256 indexed termId);\n\n    event AllocatedFundOnLoan(uint256 indexed loanId, uint256 indexed termId, uint256 assets);\n\n    function allocateTerm(uint256 loanId, uint256 termId) external;\n\n    function allocateFundOnLoan(uint256 loanId, uint256 termId, uint256 assets) external;\n}\n"
    },
    "contracts/interfaces/managers/loan/ILoanManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/// @author Quantum3 Labs\n/// @title Stormbit Loan Manager Interface\n/// TODO split into different interfaces according to funcionality\ninterface ILoanManager {\n    enum LoanStatus {\n        Pending,\n        Active,\n        Repaid,\n        Cancelled\n    }\n\n    struct Loan {\n        address borrower;\n        address token;\n        uint256 repayAssets;\n        uint256 assetsRequired;\n        uint256 assetsAllocated;\n        uint256 sharesAllocated;\n        uint256 deadlineAllocate;\n        LoanStatus status;\n    }\n\n    event LoanRequested(uint256 indexed loanId, address indexed borrower, address indexed token, uint256 assets);\n\n    event AllocatedTermAndFundOnLoan(uint256 indexed loanId, uint256 indexed termId, uint256 assets);\n\n    event LoanExecuted(uint256 indexed loanId, address indexed borrower, address indexed token, uint256 repayAssets);\n\n    event LoanRepaid(uint256 indexed loanId, address indexed repayUser);\n\n    event ClaimLoanProfit(uint256 indexed termId, uint256 indexed loanId, address indexed token, uint256 profit);\n\n    function requestLoan(address token, uint256 assets, uint256 deadline) external returns (uint256);\n\n    function allocateTermAndFundOnLoan(uint256 loanId, uint256 termId, uint256 assets) external;\n\n    function executeLoan(uint256 loanId) external;\n\n    function repay(uint256 loanId) external;\n\n    function claimLoanProfit(uint256 termId, uint256 loanId) external;\n\n    function getLoan(uint256 loanId) external view returns (Loan memory);\n\n    function getLoanTermAllocated(uint256 loanId, uint256 termId) external view returns (bool);\n\n    function getTermLoanAllocatedCounter(uint256 termId) external view returns (uint256);\n\n    function getTermAllocatedSharesOnLoan(uint256 loanId, uint256 termId, address token)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/interfaces/managers/loan/ILoanManagerView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {IAllocation} from \"./IAllocation.sol\";\nimport {ILoanRequest} from \"./ILoanRequest.sol\";\n\n/// @author Quantum3 Labs\n/// @title Stormbit Loan Manager Getter Functions Interface\n/// TODO split into different interfaces according to funcionality\ninterface ILoanManagerView {\n    function getLoan(uint256 loanId) external view returns (ILoanRequest.Loan memory);\n\n    function getLoanTermAllocated(uint256 loanId, uint256 termId) external view returns (bool);\n\n    function getTermLoanAllocatedCounter(uint256 termId) external view returns (uint256);\n\n    function getTermAllocatedSharesOnLoan(uint256 loanId, uint256 termId, address token)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/interfaces/managers/loan/ILoanRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {ILendingTerms} from \"../lending/ILendingTerms.sol\";\n\n/// @author Quantum3 Labs\n/// @title Stormbit Loan Manager Interface\n/// TODO split into different interfaces according to funcionality\ninterface ILoanRequest {\n    enum LoanStatus {\n        Pending,\n        Active,\n        Repaid,\n        Cancelled\n    }\n\n    struct Loan {\n        address borrower;\n        address token;\n        uint256 repayAssets;\n        uint256 sharesRequired;\n        uint256 sharesAllocated;\n        uint256 deadlineAllocate;\n        LoanStatus status;\n    }\n\n    event LoanRequested(uint256 indexed loanId, address indexed borrower, address indexed token, uint256 assets);\n\n    function requestLoan(address token, uint256 assets, uint256 deadline) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/token/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {IERC20 as OzIERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20 is OzIERC20 {\n    function symbol() external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/token/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {IERC4626 as OzIERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n\ninterface IERC4626 is OzIERC4626 {\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/utils/IGovernable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/// @author Quantum3 Labs\n/// @title Stormbit Admin Interface\n/// TODO split into different interfaces according to funcionality\ninterface IGovernable {\n    function governor() external view returns (address);\n}\n"
    },
    "contracts/interfaces/utils/IInitialize.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/// @author Quantum3 Labs\n/// @title Stormbit Initialize Interface\ninterface IInitialize {\n    function initialize(address loanManagerAddr, address lendingManagerAddr) external;\n}\n"
    },
    "contracts/interfaces/utils/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/// @author Quantum3 Labs\n/// @title Stormbit Pausable Interface\n/// TODO check whether we need pausable funcionalities\ninterface IPausable {}\n"
    },
    "contracts/LendingManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IERC4626} from \"./interfaces/token/IERC4626.sol\";\nimport {IGovernable} from \"./interfaces/utils/IGovernable.sol\";\nimport {IInitialize} from \"./interfaces/utils/IInitialize.sol\";\nimport {IHooks} from \"./interfaces/hooks/IHooks.sol\";\nimport {IAssetManager} from \"./interfaces/managers/asset/IAssetManager.sol\";\nimport {ILoanManager} from \"./interfaces/managers/loan/ILoanManager.sol\";\nimport {ILendingManager} from \"./interfaces/managers/lending/ILendingManager.sol\";\n\n/// @author Quantum3 Labs\n/// @title Stormbit Lending Manager\n/// @notice entrypoint for all lender and lending terms operations\n\n/// @dev Think of terms are minimal ERC4626, this contract is using word \"shares\" to represent ERC4626 assets, and \"weight\" to represent ERC4626 shares\ncontract StormbitLendingManager is Initializable, IGovernable, IInitialize, ILendingManager {\n    uint16 public constant BASIS_POINTS = 10_000;\n\n    address private _governor;\n    IAssetManager public assetManager;\n    ILoanManager public loanManager;\n\n    mapping(uint256 => ILendingManager.LendingTerm) public lendingTerms;\n    mapping(uint256 termId => mapping(address user => mapping(address vaultToken => uint256 shares))) public\n        termUserDelegatedShares; // total shares delegated by the depositor on term\n    mapping(address user => mapping(address vaultToken => uint256 delegatedShares)) // track user total delegated shares\n        public userTotalDelegatedShares;\n\n    constructor(address initialGovernor) {\n        _governor = initialGovernor;\n    }\n\n    // -----------------------------------------\n    // ------------- Modifiers -----------------\n    // -----------------------------------------\n\n    modifier onlyGovernor() {\n        require(msg.sender == _governor, \"StormbitAssetManager: not governor\");\n        _;\n    }\n\n    modifier onlyLoanManager() {\n        require(msg.sender == address(loanManager), \"StormbitLendingManager: not loan manager\");\n        _;\n    }\n\n    modifier onlyTermOwner(uint256 termId) {\n        require(lendingTerms[termId].owner == msg.sender, \"StormbitLendingManager: not term owner\");\n        _;\n    }\n\n    // -----------------------------------------\n    // -------- PUBLIC FUNCTIONS ---------------\n    // -----------------------------------------\n\n    function initialize(address assetManagerAddr, address loanManagerAddr) public override initializer {\n        assetManager = IAssetManager(assetManagerAddr);\n        loanManager = ILoanManager(loanManagerAddr);\n    }\n\n    /// @dev create a lending term\n    /// @param comission comission rate\n    /// @param hooks customizable hooks, reference uniswap v4 hooks\n    /// @return id of the lending term\n    function createLendingTerm(uint256 comission, IHooks hooks) public override returns (uint256) {\n        // unique id by hashing the sender and hooks address\n        uint256 id = uint256(keccak256(abi.encode(msg.sender, address(hooks))));\n        require(!_validLendingTerm(id), \"StormbitLendingManager: lending term already exists\");\n        lendingTerms[id].owner = msg.sender;\n        lendingTerms[id].comission = comission;\n        lendingTerms[id].hooks = hooks;\n\n        emit LendingTermCreated(id, msg.sender, comission);\n        return id;\n    }\n\n    /// @dev remove a lending term\n    /// @param id id of the lending term\n    function removeLendingTerm(uint256 id) public override onlyTermOwner(id) {\n        require(_validLendingTerm(id), \"StormbitLendingManager: lending term does not exist\");\n        // if there are delegated shares, the term cannot be removed\n        require(\n            lendingTerms[id].termNonZeroTokenCounter[id] <= 0, \"StormbitLendingManager: term has non zero token balance\"\n        );\n\n        delete lendingTerms[id];\n        emit LendingTermRemoved(id);\n    }\n\n    /// @dev allow depositor to delegate shares to a lending term\n    /// @param termId id of the lending term\n    /// @param token address of the token\n    /// @param shares amount of shares to delegate\n    function depositToTerm(uint256 termId, address token, uint256 shares) public override {\n        require(_beforeDepositToTerm(termId, token, shares), \"StormbitLendingManager: before deposit failed\");\n        require(assetManager.isTokenSupported(token), \"StormbitLendingManager: token not supported\");\n        require(_validLendingTerm(termId), \"StormbitLendingManager: lending term does not exist\");\n        require(\n            loanManager.getTermLoanAllocatedCounter(termId) == 0,\n            \"StormbitLendingManager: term already allocated to loan\"\n        );\n\n        address vaultToken = assetManager.getVaultToken(token);\n\n        // get user shares in the vault\n        uint256 userShares = assetManager.getUserShares(token, msg.sender);\n        // check if the user has enough shares\n        require(userShares >= shares, \"StormbitLendingManager: not enough shares\");\n\n        // transfer shares to lending manager\n        bool isSuccess = IERC4626(vaultToken).transferFrom(msg.sender, address(this), shares);\n        if (!isSuccess) {\n            revert(\"StormbitLendingManager: failed to transfer shares\");\n        }\n        LendingTerm storage term = lendingTerms[termId];\n\n        uint256 termSharesBalance = term.termBalances[termId][vaultToken].weight;\n\n        // check if the vault token term has 0 balance\n        if (termSharesBalance <= 0) {\n            term.termNonZeroTokenCounter[termId]++;\n        }\n\n        // update the amount of shares delegated to the term by the user\n        termUserDelegatedShares[termId][msg.sender][vaultToken] += shares;\n\n        // get current delegated shares to the term\n        uint256 currentDelegatedShares = userTotalDelegatedShares[msg.sender][vaultToken];\n\n        uint256 userCurrentTotalDelegatedShares = currentDelegatedShares + shares;\n        // update user total delegated shares, prevent scenario delegate more than user has\n        userTotalDelegatedShares[msg.sender][vaultToken] = userCurrentTotalDelegatedShares;\n\n        // update term total disposable shares\n        term.termBalances[termId][vaultToken].available += shares;\n        term.termBalances[termId][vaultToken].weight += shares;\n        term.termBalances[termId][vaultToken].shares += shares;\n\n        emit DepositToTerm(termId, msg.sender, token, shares);\n    }\n\n    /// @dev allow lender to decrease delegated shares to a lending term\n    /// @param termId id of the lending term\n    /// @param token address of the token\n    /// @param shares amount of shares to withdraw\n    function withdrawFromTerm(uint256 termId, address token, uint256 shares) public override {\n        require(_validLendingTerm(termId), \"StormbitLendingManager: lending term does not exist\");\n\n        address vaultToken = assetManager.getVaultToken(token);\n        LendingTerm storage term = lendingTerms[termId];\n\n        uint256 totalDelegatedShares = termUserDelegatedShares[termId][msg.sender][vaultToken];\n\n        // check how many percentage of shares are freezed on term\n        uint256 freezedShares =\n            term.termBalances[termId][vaultToken].shares - term.termBalances[termId][vaultToken].available;\n        uint256 freezedSharesPercentage = (freezedShares * BASIS_POINTS) / term.termBalances[termId][vaultToken].shares;\n        // get the freezeAmount from disposable shares\n        uint256 freezeAmount = (totalDelegatedShares * freezedSharesPercentage) / BASIS_POINTS;\n\n        // cannot withdraw more than disposable shares - freezeAmount\n        uint256 maximumWithdraw = totalDelegatedShares - freezeAmount;\n\n        require(shares <= maximumWithdraw, \"StormbitLendingManager: insufficient shares to withdraw\");\n\n        termUserDelegatedShares[termId][msg.sender][vaultToken] -= shares;\n        userTotalDelegatedShares[msg.sender][vaultToken] -= shares;\n\n        // convert shares to weight\n        uint256 redeemShares = getWeight(token, shares, termId);\n\n        term.termBalances[termId][vaultToken].weight -= redeemShares;\n        term.termBalances[termId][vaultToken].available -= shares;\n        term.termBalances[termId][vaultToken].shares -= shares;\n\n        // transfer shares back to user\n        bool isSuccess = IERC4626(vaultToken).transfer(msg.sender, redeemShares);\n        if (!isSuccess) {\n            revert(\"StormbitLendingManager: failed to transfer shares\");\n        }\n\n        // if term shares balance is 0, decrement the counter\n        if (term.termBalances[termId][vaultToken].shares <= 0) {\n            term.termNonZeroTokenCounter[termId]--;\n        }\n\n        emit WithdrawFromTerm(termId, msg.sender, token, shares);\n    }\n\n    /// @dev freeze the shares on term when allocated fund to loan\n    function freezeTermShares(uint256 termId, uint256 shares, address token) public override onlyLoanManager {\n        require(_validLendingTerm(termId), \"StormbitLendingManager: lending term does not exist\");\n        address vaultToken = assetManager.getVaultToken(token);\n\n        LendingTerm storage term = lendingTerms[termId];\n\n        require(\n            term.termBalances[termId][vaultToken].available >= shares,\n            \"StormbitLendingManager: insufficient disposable shares\"\n        );\n        term.termBalances[termId][vaultToken].available -= shares;\n\n        emit FreezeSharesOnTerm(termId, token, shares);\n    }\n\n    function distributeProfit(uint256 termId, address token, uint256 profit, uint256 shares, uint256 ownerProfit)\n        public\n        override\n        onlyLoanManager\n    {\n        require(_validLendingTerm(termId), \"StormbitLendingManager: lending term does not exist\");\n\n        address vaultToken = assetManager.getVaultToken(token);\n        LendingTerm storage term = lendingTerms[termId];\n\n        // transfer profit shares to term owner\n        bool isSuccess = IERC4626(vaultToken).transfer(term.owner, ownerProfit);\n        if (!isSuccess) {\n            revert(\"StormbitLendingManager: failed to transfer profit\");\n        }\n\n        term.termBalances[termId][vaultToken].weight += profit;\n        term.termBalances[termId][vaultToken].available += shares;\n\n        emit DistributeProfit(termId, token, profit);\n    }\n\n    function borrowerWithdraw(address borrower, address token, uint256 assets) public override onlyLoanManager {\n        address vaultToken = assetManager.getVaultToken(token);\n        // convert assets to shares\n        uint256 shares = assetManager.convertToShares(token, assets);\n        IERC4626(vaultToken).approve(address(assetManager), shares);\n        assetManager.borrowerWithdraw(borrower, token, assets);\n        emit BorrowerWithdraw(borrower, token, assets);\n    }\n\n    // -----------------------------------------\n    // ---------- PRIVATE FUNCTIONS ------------\n    // -----------------------------------------\n    function _beforeDepositToTerm(uint256 termId, address token, uint256 shares) private returns (bool) {\n        IHooks hooks = lendingTerms[termId].hooks;\n        // ! todo: remove this\n        if (address(hooks) == address(0) || address(hooks) == address(1)) {\n            return true;\n        }\n        return hooks.beforeDepositToTerm(msg.sender, token, termId, shares);\n    }\n\n    // -----------------------------------------\n    // ---------- INTERNAL FUNCTIONS -----------\n    // -----------------------------------------\n\n    /// @dev check if lending term exists\n    /// @param id id of the lending term\n    function _validLendingTerm(uint256 id) internal view returns (bool) {\n        return lendingTerms[id].owner != address(0);\n    }\n\n    // -----------------------------------------\n    // -------- PUBLIC GETTER FUNCTIONS --------\n    // -----------------------------------------\n\n    function governor() public view override returns (address) {\n        return _governor;\n    }\n\n    function getLendingTerm(uint256 id) public view override returns (LendingTermMetadata memory) {\n        return LendingTermMetadata(lendingTerms[id].owner, lendingTerms[id].comission, lendingTerms[id].hooks);\n    }\n\n    function getLendingTermBalances(uint256 termId, address token)\n        public\n        view\n        override\n        returns (uint256, uint256, uint256)\n    {\n        address vaultToken = assetManager.getVaultToken(token);\n        return (\n            lendingTerms[termId].termBalances[termId][vaultToken].weight,\n            lendingTerms[termId].termBalances[termId][vaultToken].available,\n            lendingTerms[termId].termBalances[termId][vaultToken].shares\n        );\n    }\n\n    function getTermFreezedShares(uint256 termId, address token) public view override returns (uint256) {\n        address vaultToken = assetManager.getVaultToken(token);\n        return lendingTerms[termId].termBalances[termId][vaultToken].shares\n            - lendingTerms[termId].termBalances[termId][vaultToken].available;\n    }\n\n    function getUserTotalDelegatedShares(address user, address token) public view override returns (uint256) {\n        address vaultToken = assetManager.getVaultToken(token);\n        return userTotalDelegatedShares[user][vaultToken];\n    }\n\n    function getWeight(address token, uint256 shares, uint256 termId) public view returns (uint256) {\n        // similar to convertToShares\n        // assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n        address vaultToken = assetManager.getVaultToken(token);\n\n        // get term\n        LendingTerm storage term = lendingTerms[termId];\n        // get term weight balance (shares)\n        uint256 termWeightBalance = term.termBalances[termId][vaultToken].weight;\n        // get term shares balance (assets)\n        uint256 termSharesBalance = term.termBalances[termId][vaultToken].shares;\n        // convert shares to weight\n        uint256 weight = (shares * termWeightBalance) / termSharesBalance;\n\n        return weight;\n    }\n}\n"
    },
    "contracts/libraries/Hooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {IHooks} from \"../interfaces/hooks/IHooks.sol\";\n\nlibrary Hooks {\n    using Hooks for IHooks;\n\n    struct Permissions {\n        bool beforeDepositToTerm;\n    }\n\n    error HookAddressNotValid(address hooks);\n\n    function validateHookPermissions(IHooks self, Permissions memory permissions) internal pure {\n        // the hook contract must implement at least one hook\n        if (!permissions.beforeDepositToTerm) {\n            revert HookAddressNotValid(address(self));\n        }\n    }\n}\n"
    },
    "contracts/LoanManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IGovernable} from \"./interfaces/utils/IGovernable.sol\";\nimport {IInitialize} from \"./interfaces/utils/IInitialize.sol\";\nimport {IERC4626} from \"./interfaces/token/IERC4626.sol\";\nimport {IAssetManager} from \"./interfaces/managers/asset/IAssetManager.sol\";\nimport {ILoanManager} from \"./interfaces/managers/loan/ILoanManager.sol\";\nimport {ILendingManager} from \"./interfaces/managers/lending/ILendingManager.sol\";\n\n/// @author Quantum3 Labs\n/// @title Stormbit Loan Manager\n/// @notice entrypoint for loan related operations\n\ncontract StormbitLoanManager is Initializable, IGovernable, IInitialize, ILoanManager {\n    uint16 public constant BASIS_POINTS = 10_000;\n\n    address private _governor;\n\n    mapping(address user => uint256 counter) public userLoanNonce;\n\n    ILendingManager public lendingManager;\n    IAssetManager public assetManager;\n\n    mapping(uint256 loanId => Loan loan) public loans;\n    mapping(uint256 loanId => mapping(uint256 termId => mapping(address vaultToken => uint256 shares))) public\n        termAllocatedShares;\n    mapping(uint256 loanId => mapping(uint256 termId => bool isAllocated)) public loanTermAllocated;\n    // a counter use to track amount of loans a term was allocated to\n    mapping(uint256 termId => uint256 loanAllocated) termLoanAllocatedCounter;\n    mapping(uint256 termId => mapping(uint256 loanId => mapping(address vaultToken => bool))) public lenderClaimedProfit; // mapping to track lender claim profit\n\n    constructor(address initialGovernor) {\n        _governor = initialGovernor;\n    }\n\n    // -----------------------------------------\n    // ------------- Modifiers -----------------\n    // -----------------------------------------\n\n    modifier onlyGovernor() {\n        require(msg.sender == _governor, \"StormbitAssetManager: not governor\");\n        _;\n    }\n\n    modifier onlyBorrower(uint256 loanId) {\n        require(loans[loanId].borrower == msg.sender, \"StormbitLoanManager: not borrower\");\n        _;\n    }\n\n    modifier onlyTermOwner(uint256 termId) {\n        address owner = lendingManager.getLendingTerm(termId).owner;\n        require(owner == msg.sender, \"StormbitLendingManager: not term owner\");\n        _;\n    }\n\n    // -----------------------------------------\n    // -------- PUBLIC FUNCTIONS ---------------\n    // -----------------------------------------\n\n    function initialize(address assetManagerAddr, address lendingManagerAddr) public override initializer {\n        assetManager = IAssetManager(assetManagerAddr);\n        lendingManager = ILendingManager(lendingManagerAddr);\n    }\n\n    /// @dev allow borrower to request loan\n    /// @param token address of the token\n    /// @param assets amount of token to borrow\n    /// @param deadline deadline of the loan to be allocated\n    /// @return loanId id of the loan\n    function requestLoan(address token, uint256 assets, uint256 deadline) public override returns (uint256) {\n        // todo: see which agreement to use\n\n        // check if token is supported\n        require(assetManager.isTokenSupported(token), \"StormbitLoanManager: token not supported\");\n\n        uint256 loanNonce = userLoanNonce[msg.sender];\n        uint256 loanId = uint256(keccak256(abi.encode(msg.sender, loanNonce)));\n        loanNonce += 1;\n        userLoanNonce[msg.sender] = loanNonce;\n\n        // todo: change the fixed rate\n        // 5% interest rate\n        uint256 repayAssets = assets + (assets * 500) / BASIS_POINTS;\n\n        loans[loanId] = Loan({\n            borrower: msg.sender,\n            token: token,\n            repayAssets: repayAssets,\n            assetsRequired: assets,\n            assetsAllocated: 0,\n            sharesAllocated: 0,\n            deadlineAllocate: deadline,\n            status: LoanStatus.Pending\n        });\n\n        emit LoanRequested(loanId, msg.sender, token, assets);\n        return loanId;\n    }\n\n    /// @dev allow borrower to execute the loan and receive the fund\n    /// @param loanId id of the loan\n    function executeLoan(uint256 loanId) public override onlyBorrower(loanId) {\n        Loan memory loan = loans[loanId];\n        // require valid loan\n        require(_validLoan(loanId), \"StormbitLoanManager: invalid loan\");\n        require(loan.status == LoanStatus.Pending, \"StormbitLoanManager: loan not pending\");\n        require(loan.assetsAllocated >= loan.assetsRequired, \"StormbitLoanManager: insufficient allocation\");\n        // only if deadline is passed\n        require(block.timestamp >= loan.deadlineAllocate, \"StormbitLoanManager: deadline not passed\");\n\n        loans[loanId].status = LoanStatus.Active;\n        lendingManager.borrowerWithdraw(\n            // withdraw by asset manager\n            loan.borrower,\n            loan.token,\n            loan.assetsRequired\n        );\n        emit LoanExecuted(loanId, loan.borrower, loan.token, loan.repayAssets);\n    }\n\n    /// @dev allow anyone to repay the loan, not restricted to borrower\n    /// @param loanId id of the loan\n    function repay(uint256 loanId) public override {\n        // check if loan is valid\n        require(_validLoan(loanId), \"StormbitLoanManager: invalid loan\");\n        Loan memory loan = loans[loanId];\n        require(loan.status == LoanStatus.Active, \"StormbitLoanManager: loan not active\");\n        assetManager.depositFrom(loan.token, loan.repayAssets, msg.sender, address(lendingManager));\n        loans[loanId].status = LoanStatus.Repaid;\n        emit LoanRepaid(loanId, msg.sender);\n    }\n\n    /// @dev allow lender to allocate fund on the loan, but only when the term is already allocated\n    /// @param loanId id of the loan\n    /// @param termId id of the term\n    /// @param assets amount of token to allocate\n    function allocateTermAndFundOnLoan(uint256 loanId, uint256 termId, uint256 assets)\n        public\n        override\n        onlyTermOwner(termId)\n    {\n        Loan memory loan = loans[loanId];\n        // check is valid loan\n        require(_validLoan(loanId), \"StormbitLoanManager: invalid loan\");\n        require(block.timestamp < loan.deadlineAllocate, \"StormbitLoanManager: deadline passed\");\n        // only if allocate deadline not passed\n        require(block.timestamp < loans[loanId].deadlineAllocate, \"StormbitLoanManager: deadline passed\");\n\n        // if first time allocate to the loan, update status\n        if (!loanTermAllocated[loanId][termId]) {\n            loanTermAllocated[loanId][termId] = true;\n            termLoanAllocatedCounter[termId] += 1;\n        }\n\n        // get disposable shares on token of the term\n        address token = loan.token;\n        // get the corresponding vault token\n        address vaultToken = assetManager.getVaultToken(token);\n        // get term owner disposable shares\n        (, uint256 termOwnerDisposableShares,) = lendingManager.getLendingTermBalances(termId, token);\n        // convert assets to shares\n        uint256 sharesRequired = assetManager.convertToShares(token, assets);\n        require(\n            termOwnerDisposableShares >= sharesRequired,\n            \"StormbitLoanManager: term owner insufficient disposable shares\"\n        );\n        // fund shares should less than loan shares required\n        require(\n            loan.assetsAllocated + assets <= loan.assetsRequired, \"StormbitLoanManager: loan assets required exceeded\"\n        );\n\n        // freeze the term owner shares\n        lendingManager.freezeTermShares(termId, sharesRequired, token);\n\n        loans[loanId].sharesAllocated += sharesRequired;\n        loans[loanId].assetsAllocated += assets;\n        termAllocatedShares[loanId][termId][vaultToken] += sharesRequired;\n\n        emit AllocatedTermAndFundOnLoan(loanId, termId, assets);\n    }\n\n    /// @dev allow lender to claim the profit for loan, then add the remaining profit to term profit\n    function claimLoanProfit(uint256 termId, uint256 loanId) public override {\n        Loan memory loan = loans[loanId];\n        address vaultToken = assetManager.getVaultToken(loan.token);\n        // check if the profit has been claimed\n        require(!lenderClaimedProfit[termId][loanId][vaultToken], \"StormbitLendingManager: profit already claimed\");\n        // get loan\n        require(loan.status == ILoanManager.LoanStatus.Repaid, \"StormbitLendingManager: loan not repaid\");\n        // term allocated on shares should > 0\n        uint256 weight = termAllocatedShares[loanId][termId][vaultToken];\n        require(weight > 0, \"StormbitLendingManager: term not allocated on loan\");\n\n        // get lending term\n        ILendingManager.LendingTermMetadata memory term = lendingManager.getLendingTerm(termId);\n        // convert repay assets to shares\n        uint256 repayShares = assetManager.convertToShares(loan.token, loan.repayAssets);\n        // calculate profit\n        // calculate shares required, convert assets to shares\n        uint256 sharesRequired = assetManager.convertToShares(loan.token, loan.assetsRequired);\n        uint256 profitShares = repayShares - sharesRequired;\n        // calculate weight of term in shares / loan required shares\n        uint256 termFundedPercent = (weight * BASIS_POINTS) / sharesRequired;\n        // term owner profit shares\n        uint256 termProfitShares = (profitShares * termFundedPercent) / BASIS_POINTS;\n        // from term profit shares, get commission for term owner\n        uint256 termOwnerProfitShares = (termProfitShares * term.comission) / BASIS_POINTS;\n        // calculate the remaining profit after term owner profit\n        uint256 extraProfit = termProfitShares - termOwnerProfitShares;\n\n        lendingManager.distributeProfit(termId, loan.token, extraProfit, weight, termOwnerProfitShares);\n\n        // update claimed status\n        lenderClaimedProfit[termId][loanId][vaultToken] = true;\n\n        // decrement term allocated counter\n        termLoanAllocatedCounter[termId] -= 1;\n\n        emit ClaimLoanProfit(termId, loanId, loan.token, termOwnerProfitShares);\n    }\n\n    // -----------------------------------------\n    // ----------- PRIVATE FUNCTIONS -----------\n    // -----------------------------------------\n    function _validLoan(uint256 loanId) private view returns (bool) {\n        return loans[loanId].borrower != address(0);\n    }\n\n    function _calculateSharesRequired(address token, uint256 assets) private view returns (uint256) {\n        // get the vault token\n        address vaultToken = assetManager.getVaultToken(token);\n        // convert assets to shares\n        uint256 sharesRequired = IERC4626(vaultToken).convertToShares(assets);\n        return sharesRequired;\n    }\n\n    // -----------------------------------------\n    // -------- PUBLIC GETTER FUNCTIONS --------\n    // -----------------------------------------\n    function governor() public view override returns (address) {\n        return _governor;\n    }\n\n    /// @dev get the loan details\n    function getLoan(uint256 loanId) public view override returns (Loan memory) {\n        return loans[loanId];\n    }\n\n    /// @dev get the allocation status of a term on a loan\n    function getLoanTermAllocated(uint256 loanId, uint256 termId) public view override returns (bool) {\n        return loanTermAllocated[loanId][termId];\n    }\n\n    /// @dev get the amount of loans a term was allocated to\n    function getTermLoanAllocatedCounter(uint256 termId) external view override returns (uint256) {\n        return termLoanAllocatedCounter[termId];\n    }\n\n    /// @dev get the allocated shares on the loan\n    function getTermAllocatedSharesOnLoan(uint256 loanId, uint256 termId, address token)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        address vaultToken = assetManager.getVaultToken(token);\n        return termAllocatedShares[loanId][termId][vaultToken];\n    }\n}\n"
    },
    "contracts/mocks/MockToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockToken is ERC20 {\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {\n        _mint(msg.sender, 200000);\n    }\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n}\n"
    },
    "contracts/StormbitRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IGovernable} from \"./interfaces/utils/IGovernable.sol\";\nimport {IInitialize} from \"./interfaces/utils/IInitialize.sol\";\nimport {IStormbitRegistry} from \"./interfaces/IStormbitRegistry.sol\";\n\n/// @author Quantum3 Labs\n/// @title Stormbit Lending Manager\n/// @notice entrypoint for all lender and lending terms operations\n\n/// @dev Think of terms are minimal ERC4626, this contract is using word \"shares\" to represent ERC4626 assets, and \"weight\" to represent ERC4626 shares\ncontract StormbitRegistry is Initializable, IGovernable, IStormbitRegistry {\n    address private _governor;\n\n    mapping(address => string) public usernames;\n\n    constructor(address initialGovernor) {\n        _governor = initialGovernor;\n    }\n\n    function governor() public view override returns (address) {\n        return _governor;\n    }\n\n    function register(string memory _username) external override {\n        require(bytes(usernames[msg.sender]).length == 0, \"StormbitRegistry: user already registered\");\n        require(bytes(_username).length > 0, \"StormbitRegistry: username is empty\");\n\n        usernames[msg.sender] = _username;\n\n        emit Registered(msg.sender, _username);\n    }\n}\n"
    },
    "contracts/vaults/BaseVault.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {ERC4626} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {StormbitAssetManager} from \"../AssetManager.sol\";\n\ncontract BaseVault is ERC4626 {\n    error OnlyAssetManager();\n\n    StormbitAssetManager private assetManager;\n\n    constructor(IERC20 _token, address assetManagerAddr, string memory _name, string memory _symbol)\n        ERC4626(_token)\n        ERC20(_name, _symbol)\n    {\n        assetManager = StormbitAssetManager(assetManagerAddr);\n    }\n\n    modifier onlyAssetManager() {\n        if (msg.sender != address(assetManager)) revert OnlyAssetManager();\n        _;\n    }\n\n    function deposit(uint256 assets, address receiver) public override onlyAssetManager returns (uint256) {\n        return super.deposit(assets, receiver);\n    }\n\n    function mint(uint256 shares, address receiver) public override onlyAssetManager returns (uint256) {\n        return super.mint(shares, receiver);\n    }\n\n    function withdraw(uint256 assets, address receiver, address owner)\n        public\n        override\n        onlyAssetManager\n        returns (uint256)\n    {\n        return super.withdraw(assets, receiver, owner);\n    }\n\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        override\n        onlyAssetManager\n        returns (uint256)\n    {\n        return super.redeem(shares, receiver, owner);\n    }\n\n    function depositToStrategy() external onlyAssetManager {\n        // some logic\n    }\n\n    function withdrawFromStrategy() external onlyAssetManager {\n        // some logic\n    }\n\n    function _decimalsOffset() internal view override returns (uint8) {\n        return 8;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 5
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}